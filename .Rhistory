consumer_data$category_diversity <- rowSums(consumer_data[, category_columns] > 0)
# Select relevant columns for each clustering segment
behavior_data <- consumer_data %>%
select(log_total_purchase_volume, brand_loyalty_score, no_of_trans)
basis_data <- consumer_data %>%
select(deal_sensitivity, category_diversity)
combined_data <- consumer_data %>%
select(log_total_purchase_volume, brand_loyalty_score, no_of_trans, deal_sensitivity, category_diversity)
# ---------------------- Elbow Method ---------------------- #
# Function to calculate WSS (within-cluster sum of squares) for a range of clusters
elbow_method <- function(data, max_clusters = 10) {
wss <- sapply(1:max_clusters, function(k) {
kmeans(data, centers = k, nstart = 25)$tot.withinss
})
plot(1:max_clusters, wss, type = "b", pch = 19, frame = FALSE,
xlab = "Number of Clusters", ylab = "Total Within-Cluster Sum of Squares",
main = paste("Elbow Method for Optimal Clusters in", deparse(substitute(data))))
}
# Elbow plots for each dataset
elbow_method(behavior_data, max_clusters = 10)
elbow_method(basis_data, max_clusters = 10)
elbow_method(combined_data, max_clusters = 10)
# ---------------------- Silhouette Analysis ---------------------- #
# Function to plot silhouette scores for a range of clusters
silhouette_analysis <- function(data, max_clusters = 10) {
avg_sil_width <- sapply(2:max_clusters, function(k) {
km <- kmeans(data, centers = k, nstart = 25)
ss <- silhouette(km$cluster, dist(data))
mean(ss[, 3])
})
plot(2:max_clusters, avg_sil_width, type = "b", pch = 19, frame = FALSE,
xlab = "Number of Clusters", ylab = "Average Silhouette Width",
main = paste("Silhouette Analysis for Optimal Clusters in", deparse(substitute(data))))
}
# Silhouette analysis for each dataset
silhouette_analysis(behavior_data, max_clusters = 10)
silhouette_analysis(basis_data, max_clusters = 10)
silhouette_analysis(combined_data, max_clusters = 10)
# 1. Purchase Behavior Clustering with 3 Clusters
cat("---- Purchase Behavior Clustering with 3 Clusters ----\n")
set.seed(123)
optimal_clusters_behavior <- 3
kmeans_behavior <- kmeans(behavior_data, centers = optimal_clusters_behavior, nstart = 25)
consumer_data$cluster_behavior <- kmeans_behavior$cluster
# Silhouette Analysis for Purchase Behavior Clustering
silhouette_behavior <- silhouette(kmeans_behavior$cluster, dist(behavior_data))
avg_silhouette_behavior <- mean(silhouette_behavior[, 3])
# Print silhouette values
cat("Average Silhouette Score for Purchase Behavior Clustering with 3 clusters:", round(avg_silhouette_behavior, 3), "\n")
print(table(consumer_data$cluster_behavior))
plot(
silhouette_behavior,
col = 1:optimal_clusters_behavior,
border = NA,
main = "Silhouette Plot for Purchase Behavior Clustering with 3 Clusters"
)
# Purchase Behavior Clustering: Cluster Centers Plot
cluster_centers_behavior <- as.data.frame(kmeans_behavior$centers)
cluster_centers_behavior$Feature <- rownames(cluster_centers_behavior)
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
cluster_centers_behavior_long$Cluster <- as.factor(cluster_centers_behavior_long$Cluster)
ggplot(cluster_centers_behavior_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Purchase Behavior)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Define colors based on cluster (as per the silhouette plot colors)
cluster_centers_behavior_long$Cluster <- factor(cluster_centers_behavior_long$Cluster, levels = c(1, 2, 3))
cluster_centers_behavior_long$ClusterColor <- factor(cluster_centers_behavior_long$Cluster,
labels = c("black", "red", "green"))
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Purchase Behavior Clustering: Cluster Centers Plot with Matching Colors
cluster_centers_behavior <- as.data.frame(kmeans_behavior$centers)
cluster_centers_behavior$Feature <- rownames(cluster_centers_behavior)
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Plot with customized colors
ggplot(cluster_centers_behavior_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Purchase Behavior)",
x = "Feature", y = "Average Value") +
scale_fill_manual(values = c("1" = "black", "2" = "red", "3" = "green")) +  # Match the colors
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Purchase Behavior Clustering: Cluster Centers Plot with Matching Colors
cluster_centers_behavior <- as.data.frame(kmeans_behavior$centers)
cluster_centers_behavior$Feature <- rownames(cluster_centers_behavior)
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Ensure that 'Cluster' is a factor with the correct levels
cluster_centers_behavior_long$Cluster <- factor(cluster_centers_behavior_long$Cluster, levels = c("1", "2", "3"))
# Plot with customized colors
ggplot(cluster_centers_behavior_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Purchase Behavior)",
x = "Feature", y = "Average Value") +
scale_fill_manual(values = c("1" = "black", "2" = "red", "3" = "green")) +  # Match the colors
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Purchase Behavior Clustering: Cluster Centers Plot
cluster_centers_behavior <- as.data.frame(kmeans_behavior$centers)
cluster_centers_behavior$Feature <- rownames(cluster_centers_behavior)
cluster_centers_behavior_long <- tidyr::pivot_longer(
cluster_centers_behavior,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Basic plot without customizing colors
ggplot(cluster_centers_behavior_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Purchase Behavior)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 2. Basis for Purchase Clustering with 3 Clusters
cat("\n---- Basis for Purchase Clustering with 3 Clusters ----\n")
set.seed(123)
optimal_clusters_basis <- 3
kmeans_basis <- kmeans(basis_data, centers = optimal_clusters_basis, nstart = 25)
consumer_data$cluster_basis <- kmeans_basis$cluster
# Silhouette Analysis for Basis for Purchase Clustering
silhouette_basis <- silhouette(kmeans_basis$cluster, dist(basis_data))
avg_silhouette_basis <- mean(silhouette_basis[, 3])
# Print silhouette values
cat("Average Silhouette Score for Basis for Purchase Clustering with 3 clusters:", round(avg_silhouette_basis, 3), "\n")
print(table(consumer_data$cluster_basis))
plot(
silhouette_basis,
col = 1:optimal_clusters_basis,
border = NA,
main = "Silhouette Plot for Basis for Purchase Clustering with 3 Clusters"
)
# Basis for Purchase Clustering: Cluster Centers Plot
cluster_centers_basis <- as.data.frame(kmeans_basis$centers)
cluster_centers_basis$Feature <- rownames(cluster_centers_basis)
cluster_centers_basis_long <- tidyr::pivot_longer(
cluster_centers_basis,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
cluster_centers_basis_long$Cluster <- as.factor(cluster_centers_basis_long$Cluster)
ggplot(cluster_centers_basis_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Basis for Purchase)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Basis for Purchase Clustering: Cluster Centers Plot with Enhanced Features
cluster_centers_basis <- as.data.frame(kmeans_basis$centers)
cluster_centers_basis$Feature <- rownames(cluster_centers_basis)
cluster_centers_basis_long <- tidyr::pivot_longer(
cluster_centers_basis,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Ensure 'Cluster' is a factor
cluster_centers_basis_long$Cluster <- as.factor(cluster_centers_basis_long$Cluster)
# Plot with adjustments for readability and clarity
ggplot(cluster_centers_basis_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Basis for Purchase)",
x = "Feature", y = "Average Value") +
scale_fill_manual(values = c("1" = "black", "2" = "red", "3" = "green")) +  # Match the colors
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_y_continuous(labels = scales::comma)  # Adds better formatting to y-axis values
# Ensure 'Cluster' is a factor
cluster_centers_basis_long$Cluster <- as.factor(cluster_centers_basis_long$Cluster)
# Plot cluster centers
ggplot(cluster_centers_basis_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Basis for Purchase)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
basis_data <- consumer_data %>%
select(deal_sensitivity, category_diversity, no_of_trans)
set.seed(123)
optimal_clusters_basis <- 3
kmeans_basis <- kmeans(basis_data, centers = optimal_clusters_basis, nstart = 25)
consumer_data$cluster_basis <- kmeans_basis$cluster
# Silhouette Analysis for Basis for Purchase Clustering
silhouette_basis <- silhouette(kmeans_basis$cluster, dist(basis_data))
avg_silhouette_basis <- mean(silhouette_basis[, 3])
# Print silhouette values
cat("Average Silhouette Score for Basis for Purchase Clustering with 3 clusters:", round(avg_silhouette_basis, 3), "\n")
print(table(consumer_data$cluster_basis))
plot(
silhouette_basis,
col = 1:optimal_clusters_basis,
border = NA,
main = "Silhouette Plot for Basis for Purchase Clustering with 3 Clusters"
)
# Basis for Purchase Clustering: Cluster Centers Plot
cluster_centers_basis <- as.data.frame(kmeans_basis$centers)
cluster_centers_basis$Feature <- rownames(cluster_centers_basis)
# Reshape the cluster centers to long format for easy plotting
cluster_centers_basis_long <- tidyr::pivot_longer(
cluster_centers_basis,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
# Ensure 'Cluster' is a factor
cluster_centers_basis_long$Cluster <- as.factor(cluster_centers_basis_long$Cluster)
# Plot cluster centers
ggplot(cluster_centers_basis_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Basis for Purchase)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 3. Combined Clustering with 3 Clusters
cat("\n---- Combined Clustering with 3 Clusters ----\n")
set.seed(123)
optimal_clusters_combined <- 3
kmeans_combined <- kmeans(combined_data, centers = optimal_clusters_combined, nstart = 25)
consumer_data$cluster_combined <- kmeans_combined$cluster
# Silhouette Analysis for Combined Clustering
silhouette_combined <- silhouette(kmeans_combined$cluster, dist(combined_data))
avg_silhouette_combined <- mean(silhouette_combined[, 3])
# Print silhouette values
cat("Average Silhouette Score for Combined Clustering with 3 clusters:", round(avg_silhouette_combined, 3), "\n")
print(table(consumer_data$cluster_combined))
plot(
silhouette_combined,
col = 1:optimal_clusters_combined,
border = NA,
main = "Silhouette Plot for Combined Clustering with 3 Clusters"
)
# Combined Clustering: Cluster Centers Plot
cluster_centers_combined <- as.data.frame(kmeans_combined$centers)
cluster_centers_combined$Feature <- rownames(cluster_centers_combined)
cluster_centers_combined_long <- tidyr::pivot_longer(
cluster_centers_combined,
cols = -Feature,
names_to = "Cluster",
values_to = "Average Value"
)
cluster_centers_combined_long$Cluster <- as.factor(cluster_centers_combined_long$Cluster)
ggplot(cluster_centers_combined_long, aes(x = Feature, y = `Average Value`, fill = Cluster)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Cluster Centers by Feature (Combined)",
x = "Feature", y = "Average Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
head(cluster_combined)
head(combined_data)
print(colnames(combined_data))
# --------------------- Step 1: Data Preparation for Combined Clustering ---------------------- #
# Ensure the dataset includes the combined clusters
combined_cluster_data <- consumer_data %>%
filter(cluster_combined %in% c(1, 2)) %>%  # Adjust clusters based on business goal
mutate(
# Define total spend for potential high-value consumers
total_spend = total_volume * avg_price,
# Target for value-conscious classification: high spenders or frequent buyers (top 25% in spend or transactions)
value_conscious = ifelse(total_spend > quantile(total_spend, 0.75) |
no_of_trans > quantile(no_of_trans, 0.75), 1, 0),
# Target for brand loyalty prediction: define based on 'brand_runs' (frequency of same brand purchases)
brand_loyalty = ifelse(brand_runs > quantile(brand_runs, 0.75), 1, 0)
) %>%
select(-total_spend, -cluster_behavior, -cluster_basis, -cluster_combined)  # Remove clustering columns post-target creation
# --------------------- Step 2: Create Datasets for Each Task ---------------------- #
# Dataset for Value-Conscious Classification
classification_data <- combined_cluster_data %>%
select(value_conscious, brand_loyalty_score, log_total_purchase_volume,
category_diversity, affluence_index, no_of_trans, avg_price)
# Dataset for Brand Loyalty Prediction
prediction_data <- combined_cluster_data %>%
select(brand_loyalty, brand_loyalty_score, log_total_purchase_volume,
category_diversity, affluence_index, no_of_trans, avg_price)
# Verify target distribution for each dataset
cat("Distribution of Value-Conscious Target:\n")
print(table(classification_data$value_conscious))
cat("Distribution of Brand Loyalty Target:\n")
print(table(prediction_data$brand_loyalty))
colnames(classification_data)
colnames(prediction_data)
# Refine classification data by removing predictors tied to value_conscious
classification_data_refined <- classification_data %>%
select(value_conscious, category_diversity, affluence_index, avg_price)
# Refine prediction data by removing predictors tied to brand_loyalty
prediction_data_refined <- prediction_data %>%
select(brand_loyalty, category_diversity, affluence_index, avg_price)
# Print refined column names to confirm removal
cat("Refined Columns for Classification:\n")
print(colnames(classification_data_refined))
cat("\nRefined Columns for Prediction:\n")
print(colnames(prediction_data_refined))
colnames(classification_data)
# Refine the classification dataset by removing derived features
classification_data_refined <- classification_data %>%
select(value_conscious, category_diversity, affluence_index, avg_price, no_of_trans)  # Exclude brand_loyalty_score, log_total_purchase_volume
colnames(classification_data_refined)
# Set seed for reproducibility
set.seed(123)
# Split data into training (70%) and test (30%) sets
split_index <- sample(seq_len(nrow(classification_data_refined)), size = 0.7 * nrow(classification_data_refined))
train_data <- classification_data_refined[split_index, ]
test_data <- classification_data_refined[-split_index, ]
# Check the distribution of the target variable in the training and test sets
cat("Training set distribution:\n")
print(table(train_data$value_conscious))
cat("Test set distribution:\n")
print(table(test_data$value_conscious))
# Fit logistic regression model on the training data
value_conscious_model <- glm(value_conscious ~ ., data = train_data, family = binomial)
# Summarize the model to inspect coefficients and significance
summary(value_conscious_model)
# Step 3: Predict on Test Set
pred_value_conscious <- predict(value_conscious_model, newdata = test_data, type = "response")
pred_value_conscious_class <- ifelse(pred_value_conscious > 0.5, 1, 0)
# Confusion Matrix and Model Performance
conf_matrix_value <- confusionMatrix(factor(pred_value_conscious_class), factor(test_data$value_conscious))
cat("Confusion Matrix for Value-Conscious Classification:\n")
print(conf_matrix_value)
# Set seed for reproducibility
set.seed(123)
# Split data into training (70%) and test (30%) sets
split_index <- sample(seq_len(nrow(classification_data_refined)), size = 0.7 * nrow(classification_data_refined))
train_data <- classification_data_refined[split_index, ]
test_data <- classification_data_refined[-split_index, ]
# Check the distribution of the target variable in the training and test sets
cat("Training set distribution:\n")
print(table(train_data$value_conscious))
cat("Test set distribution:\n")
print(table(test_data$value_conscious))
# Fit logistic regression model on the training data
value_conscious_model <- glm(value_conscious ~ ., data = train_data, family = binomial)
# Summarize the model to inspect coefficients and significance
summary(value_conscious_model)
# Step 3: Predict on Test Set
pred_value_conscious <- predict(value_conscious_model, newdata = test_data, type = "response")
pred_value_conscious_class <- ifelse(pred_value_conscious > 0.5, 1, 0)
# Confusion Matrix and Model Performance with explicit positive class = 1
conf_matrix_value <- confusionMatrix(factor(pred_value_conscious_class), factor(test_data$value_conscious), positive = "1")
cat("Confusion Matrix for Value-Conscious Classification:\n")
print(conf_matrix_value)
# --------------------- Step 1: Data Preparation for Brand Loyalty Prediction ---------------------- #
# Ensure the dataset includes the combined clusters for high-value consumers
brand_loyalty_data <- consumer_data %>%
filter(cluster_combined %in% c(1, 2)) %>%  # Adjust clusters based on business goal
mutate(
# Define total spend for potential high-value consumers
total_spend = total_volume * avg_price,
# Target for brand loyalty prediction: high-frequency buyers or consistent brand purchases
brand_loyalty = ifelse(brand_runs > quantile(brand_runs, 0.75), 1, 0)
) %>%
select(-total_spend, -cluster_behavior, -cluster_basis, -cluster_combined)  # Remove clustering columns
# Dataset for Brand Loyalty Prediction with refined columns
# Avoid derived predictors or those that correlate highly with the target variable
prediction_data <- brand_loyalty_data %>%
select(brand_loyalty, category_diversity, affluence_index, avg_price, no_of_trans)  # Remove brand_loyalty_score, log_total_purchase_volume
# Confirm the columns for prediction to ensure minimal multicollinearity and relevance
cat("Columns for Brand Loyalty Prediction:\n")
print(colnames(prediction_data))
# Set seed for reproducibility
set.seed(123)
# Split data into training (70%) and test (30%) sets
split_index_loyalty <- sample(seq_len(nrow(prediction_data)), size = 0.7 * nrow(prediction_data))
train_data_loyalty <- prediction_data[split_index_loyalty, ]
test_data_loyalty <- prediction_data[-split_index_loyalty, ]
# Check the distribution of the target variable in the training and test sets
cat("Training set distribution for Brand Loyalty:\n")
print(table(train_data_loyalty$brand_loyalty))
cat("Test set distribution for Brand Loyalty:\n")
print(table(test_data_loyalty$brand_loyalty))
# Fit logistic regression model for brand loyalty on the training data
brand_loyalty_model <- glm(brand_loyalty ~ ., data = train_data_loyalty, family = binomial)
# Summarize the model to inspect coefficients and significance
summary(brand_loyalty_model)
# Predictions on the test set
pred_brand_loyalty <- predict(brand_loyalty_model, newdata = test_data_loyalty, type = "response")
pred_brand_loyalty_class <- ifelse(pred_brand_loyalty > 0.5, 1, 0)
# Confusion Matrix and Model Performance
conf_matrix_loyalty <- confusionMatrix(factor(pred_brand_loyalty_class), factor(test_data_loyalty$brand_loyalty), positive = "1")
cat("Confusion Matrix for Brand Loyalty Prediction:\n")
print(conf_matrix_loyalty)
# Model Accuracy
cat("Model Accuracy for Brand Loyalty Prediction:\n")
print(conf_matrix_loyalty$overall["Accuracy"])
# Load required library
library(pROC)
# ROC Curve for Value-Conscious Classification Model
roc_value_conscious <- roc(test_data$value_conscious, pred_value_conscious)
auc_value_conscious <- auc(roc_value_conscious)
# ROC Curve for Brand Loyalty Prediction Model
roc_brand_loyalty <- roc(test_data_loyalty$brand_loyalty, pred_brand_loyalty)
auc_brand_loyalty <- auc(roc_brand_loyalty)
# Plotting both ROC curves
plot(roc_value_conscious, col = "blue", lwd = 2, main = "ROC Curves for Classification Models")
lines(roc_brand_loyalty, col = "green", lwd = 2)
# Adding legend and AUC labels
legend("bottomright", legend = c(paste("Value-Conscious Model (AUC =", round(auc_value_conscious, 2), ")"),
paste("Brand Loyalty Model (AUC =", round(auc_brand_loyalty, 2), ")")),
col = c("blue", "green"), lwd = 2, cex = 0.7)
# Convert the target variable to a factor for classification
train_data_loyalty$brand_loyalty <- as.factor(train_data_loyalty$brand_loyalty)
test_data_loyalty$brand_loyalty <- as.factor(test_data_loyalty$brand_loyalty)
# Fit a Random Forest model on the training data for brand loyalty classification
set.seed(123)  # for reproducibility
#---------------------Value Conscious Classification ---------------Random Forest------------#
# Convert target variable to a factor for classification
train_data$value_conscious <- as.factor(train_data$value_conscious)
test_data$value_conscious <- as.factor(test_data$value_conscious)
# Fit a Random Forest model on the training data for classification
value_conscious_rf_model <- randomForest(value_conscious ~ ., data = train_data, ntree = 500, mtry = 2, importance = TRUE)
# Display the model summary
print(value_conscious_rf_model)
# Feature importance
importance(value_conscious_rf_model)
varImpPlot(value_conscious_rf_model, main = "Feature Importance for Value-Conscious Classification")
# Predict on the test set
pred_value_conscious_rf <- predict(value_conscious_rf_model, newdata = test_data)
# Confusion Matrix and Model Performance
conf_matrix_value_rf <- confusionMatrix(factor(pred_value_conscious_rf), test_data$value_conscious)
cat("Confusion Matrix for Value-Conscious Classification (Random Forest):\n")
print(conf_matrix_value_rf)
# Model Accuracy
cat("Random Forest Model Accuracy:\n")
print(conf_matrix_value_rf$overall["Accuracy"])
# Convert the target variable to a factor for classification
train_data_loyalty$brand_loyalty <- as.factor(train_data_loyalty$brand_loyalty)
test_data_loyalty$brand_loyalty <- as.factor(test_data_loyalty$brand_loyalty)
# Fit a Random Forest model on the training data for brand loyalty classification
set.seed(123)  # for reproducibility
brand_loyalty_rf_model <- randomForest(brand_loyalty ~ ., data = train_data_loyalty, ntree = 500, mtry = 2, importance = TRUE)
# Display the model summary
print(brand_loyalty_rf_model)
# Feature importance
importance(brand_loyalty_rf_model)
varImpPlot(brand_loyalty_rf_model, main = "Feature Importance for Brand Loyalty Classification")
# Predict on the test set
pred_brand_loyalty_rf <- predict(brand_loyalty_rf_model, newdata = test_data_loyalty)
# Confusion Matrix and Model Performance
conf_matrix_loyalty_rf <- confusionMatrix(pred_brand_loyalty_rf, test_data_loyalty$brand_loyalty)
cat("Confusion Matrix for Brand Loyalty Classification (Random Forest):\n")
print(conf_matrix_loyalty_rf)
# Model Accuracy
cat("Random Forest Model Accuracy for Brand Loyalty:\n")
print(conf_matrix_loyalty_rf$overall["Accuracy"])
# Ensure the dataset includes combined clusters for high-value consumers
brand_runs_data <- consumer_data %>%
filter(cluster_combined %in% c(1, 2)) %>%  # Adjust clusters based on business goal
select(brand_runs, category_diversity, affluence_index, avg_price, no_of_trans, total_volume)
# Set seed for reproducibility
set.seed(123)
# Split data into training (70%) and test (30%) sets
split_index_runs <- sample(seq_len(nrow(brand_runs_data)), size = 0.7 * nrow(brand_runs_data))
train_data_runs <- brand_runs_data[split_index_runs, ]
test_data_runs <- brand_runs_data[-split_index_runs, ]
# Check distribution of brand runs in training and test sets
cat("Training set summary:\n")
print(summary(train_data_runs$brand_runs))
cat("Test set summary:\n")
print(summary(test_data_runs$brand_runs))
# Fit linear regression model on the training set
brand_runs_model <- lm(brand_runs ~ ., data = train_data_runs)
# Summarize the model to inspect coefficients and significance
summary(brand_runs_model)
# Predictions on the test set
pred_brand_runs <- predict(brand_runs_model, newdata = test_data_runs)
# Calculate Mean Absolute Error (MAE) and Mean Squared Error (MSE) for model evaluation
mae <- mean(abs(pred_brand_runs - test_data_runs$brand_runs))
mse <- mean((pred_brand_runs - test_data_runs$brand_runs)^2)
# Print evaluation metrics
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
# Calculate RMSE (Root Mean Squared Error) and MAPE (Mean Absolute Percentage Error)
rmse <- sqrt(mean((pred_brand_runs - test_data_runs$brand_runs)^2))
mape <- mean(abs((test_data_runs$brand_runs - pred_brand_runs) / test_data_runs$brand_runs)) * 100
# Print RMSE and MAPE
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
cat("Mean Absolute Percentage Error (MAPE):", mape, "%\n")
# Plot to visualize predicted vs. actual values
library(ggplot2)
ggplot(data = NULL, aes(x = test_data_runs$brand_runs, y = pred_brand_runs)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs. Actual Brand Runs",
x = "Actual Brand Runs",
y = "Predicted Brand Runs") +
theme_minimal()
